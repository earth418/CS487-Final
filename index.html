<!DOCTYPE html>
<html lang="en">
<head>
    <title>CPSC 487/587</title>
    <script src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script>
    <script id="MathJax-script" async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/lil-gui@0.19.1/dist/lil-gui.umd.min.js"></script>
    <!-- <script src="https://cdnjs.cloudflare.com/ajax/libs/mathjs/10.3.0/math.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/quaternion@1.5.1/quaternion.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/numeric@1.2.6/numeric-1.2.6.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/stats.js@0.17.0/build/stats.min.js"></script> -->
    <script type="importmap">
        {
            "imports": {
              "three": "https://unpkg.com/three@0.160.0/build/three.module.js",
              "three/": "https://unpkg.com/three@0.160.0/"
            }
        }
    </script>
</head>
<body>
<script type="module">
    import * as THREE from 'three';
    import { GLTFLoader } from 'three/examples/jsm/loaders/GLTFLoader.js';
    // import { get_rpy_SO3_matrix } from './js/utils/utils_euler_angles    .js';
    import { optimization_solve } from './js/utils/utils_optimization.js';

    import {ThreeEngine, get_default_lil_gui, refresh_displays} from "./js/utils/utils_three.js";
    // import {B1Z1Robot, XArm7Robot, RobotJointPrismatic, RobotJointRevolute} from "js/utils/utils_robot.js";
    import {mul_matrix_matrix, mul_matrix_scalar, add_matrix_matrix, 
        sub_matrix_matrix, identity_matrix, transpose,
    roll_list_into_matrix, unroll_matrix_to_list } from "./js/utils/utils_math.js";

    import {TransformGizmoEngine} from "./js/utils/utils_transform_gizmo.js";

    // from PA_3

    function matrix_inverse_3x3(A) {
        let det = A[0][0] * (A[1][1] * A[2][2] - A[2][1] * A[1][2]) -
            A[0][1] * (A[1][0] * A[2][2] - A[1][2] * A[2][0]) +
            A[0][2] * (A[1][0] * A[2][1] - A[1][1] * A[2][0]);

        if (det === 0) {
            return null; // No inverse exists if determinant is 0
        }

        let cofactors = [
            [
                (A[1][1] * A[2][2] - A[2][1] * A[1][2]),
                -(A[1][0] * A[2][2] - A[1][2] * A[2][0]),
                (A[1][0] * A[2][1] - A[2][0] * A[1][1])
            ],
            [
                -(A[0][1] * A[2][2] - A[0][2] * A[2][1]),
                (A[0][0] * A[2][2] - A[0][2] * A[2][0]),
                -(A[0][0] * A[2][1] - A[2][0] * A[0][1])
            ],
            [
                (A[0][1] * A[1][2] - A[0][2] * A[1][1]),
                -(A[0][0] * A[1][2] - A[1][0] * A[0][2]),
                (A[0][0] * A[1][1] - A[1][0] * A[0][1])
            ]
        ];

        let adjugate = [
            [cofactors[0][0] / det, cofactors[1][0] / det, cofactors[2][0] / det],
            [cofactors[0][1] / det, cofactors[1][1] / det, cofactors[2][1] / det],
            [cofactors[0][2] / det, cofactors[1][2] / det, cofactors[2][2] / det]
        ];

        return adjugate;
    }

    // for the inverse

    // Procedural Animation
    // Using class code
    // And a custom-made model

    let engine = ThreeEngine.new_default_3d();

    let gizmos = new TransformGizmoEngine(engine);
    let gizmo = gizmos.add_gizmo_SE3_matrix(engine);

    let loader = new GLTFLoader();

    const s = await loader.loadAsync('./fourlegs.glb');
    engine.scene.add(s.scene);

    let epsilon = 0.001;

    // let root_bone = s.scene.children[0].children[1];
    let root_bone = s.scene.children[0];
    console.log(root_bone);
    
    let legs = root_bone.children;

    // alert(1);

    // legs[0].position = new THREE.Vector3(0.0, 0.0, 0.0);
    // legs[0].translateX(5.0);

    // let joints = robot.joints;
    // let links = robot.links;
    
    let params = [];

    // location of entire body
    params.push(0.0);
    params.push(0.0);
    params.push(0.0);
        
    // axis of rotation * angle of body
    params.push(0.0);
    params.push(0.0);
    params.push(0.0);

    legs.forEach((leg) => {
        // axis of rotation * angle (vector U) at thigh
        params.push(0.0);
        params.push(0.0);
        params.push(0.0);

        // location of knee joint
        params.push(0.0);
        params.push(0.0);
        params.push(0.0);
        
        // axis of rotation * angle of knee joint
        params.push(0.0);
        params.push(0.0);
        params.push(0.0);

        // position of foot joint
        params.push(0.0);
        params.push(0.0);
        params.push(0.0);
    });
    
    function roll_up(list) {
        return [[list[0], list[4], list[8], list[12]],
               [list[1], list[5], list[9], list[13]],
               [list[2], list[6], list[10], list[14]],
               [list[3], list[7], list[11], list[15]]];
    }
    
    function unroll(list) {
        return [list[0][0], list[0][1], list[0][2], list[0][3],
                list[1][0], list[1][1], list[1][2], list[1][3],
                list[2][0], list[2][1], list[2][2], list[2][3],
                list[3][0], list[3][1], list[3][2], list[3][3]];    
    }

    function mat_from_se3(se3) {
        let m = new THREE.Matrix4();
        // m.fromArray(unroll(se3));
        m.elements = unroll(se3);
        // console.log("elements:", m.elements);
        // console.log("elements:", m);
        return m;
    }

    function se3_from_mat(mat) {
        // console.log("elements:", mat.elements);
        // console.log("elements child:", mat.elements[0].elements);
        // console.log("elements:", mat);
        let array = mat.elements;
        // console.log(array);
        return roll_up(array);
    }

        // keep this just about where the legs are orginally


    let v = mat_from_se3(se3_from_uvector([1.0, 0.0, 5.0]));

    // console.log(v);
    // let sm = se3_from_mat(legs[0].matrix);
    // console.log("before:");
    // console.log(sm);
    // legs[0].applyMatrix4(v);
    // legs[0].updateMatrix();
    // console.log("after:")
    // console.log(legs[0].matrix);
    
    // alert("h");

    let default_transforms = [];
    default_transforms.push(se3_from_mat(root_bone.matrix));
    legs.forEach((leg) => {
        default_transforms.push({
            thigh: se3_from_mat(leg.matrix),
            knee: se3_from_mat(leg.children[0].matrix)
        });
    });

    let ik_targets = [se3_from_uvector([0.0, 0.0, 0.0])];
    legs.forEach((leg) => {
        ik_targets.push({
            thigh: se3_from_mat(leg.matrix),
            knee: se3_from_mat(leg.children[0].matrix)
        });
    }); // these are RELATIVE locations!!

    // console.log("ik targets");
    // console.log(ik_targets);
    
    let settings = {
        dof0 : 0.0,
        dof1 : 0.0,
        dof2 : 0.0,
        dof3 : 0.0,
        dof4 : 0.0,
        dof5 : 0.0,
    };
    
    let gui = get_default_lil_gui();

    for (let i = 0; i < 6; ++i) {
        gui.add(settings, "dof" + i, -4, 4).name("dof" + i);
    }
    // gui.add(settings, "reset", button);

    // ALL OF THIS IS FROM PSET 3
     
    function matrix_trace(matrix) {
        let s = 0;
        for (let i = 0; i < matrix.length; ++i) {
            s += matrix[i][i];
        }
        return s;
    }

    function get_SE3_rot_part(SE3_inp) {
        return [[SE3_inp[0][0], SE3_inp[0][1], SE3_inp[0][2]],
                [SE3_inp[1][0], SE3_inp[1][1], SE3_inp[1][2]],
                [SE3_inp[2][0], SE3_inp[2][1], SE3_inp[2][2]]];
    }

    function get_SE3_trans_part(SE3_inp) {
        return [[SE3_inp[0][3]], [SE3_inp[1][3]], [SE3_inp[2][3]]];
    }

    function SE3_log(mat_inp) {
        let R = get_SE3_rot_part(mat_inp);

        let Rt = transpose(R);
        let beta = Math.acos((matrix_trace(R) - 1.0) / 2.0);
        let A = identity_matrix(3);
        if (beta < epsilon) {
            let p = 0.5 + beta*beta / 12.0 + 7 * Math.pow(beta, 4) / 720.0;
            A = mul_matrix_scalar(sub_matrix_matrix(R, Rt), p);
        } else if (Math.abs(beta - Math.PI) < epsilon) {
            function bpi_helper(i,j) {
                return Math.PI * Math.sqrt(0.5 + 0.5 * R[i][j]);
            };
            A = [[0.0, -bpi_helper(2,2), bpi_helper(1,1)],
                 [bpi_helper(2,2), 0.0, -bpi_helper(0,0)],
                 [-bpi_helper(1,1), bpi_helper(0,0), 0.0]];
        } else {
            let p = beta / (2 * Math.sin(beta));
            A = mul_matrix_scalar(sub_matrix_matrix(R, Rt), p);
        }

        // console.log(A);
        let a1 = A[2][1];
        let a2 = A[0][2];
        let a3 = A[1][0];

        let u = 0.0;
        let v = 0.0;
        let t = get_SE3_trans_part(mat_inp);

        if (beta < epsilon) {
            u = 0.5 - beta*beta / (24.0) + Math.pow(beta, 4) / (720.0);
            v = 1.0/6.0 - beta*beta / 120.0 + Math.pow(beta, 4) / (720.0*7);
        } else {
            u = (1 - Math.cos(beta)) / (beta * beta);
            v = (beta - Math.sin(beta)) / Math.pow(beta,3);
        }

        let B = mul_matrix_matrix(A,A);
        let Bprod = mul_matrix_scalar(B, v);
        let Aprod = mul_matrix_scalar(A, u);

        let prod = add_matrix_matrix(identity_matrix(3), add_matrix_matrix(Bprod, Aprod));

        let b = mul_matrix_matrix(matrix_inverse_3x3(prod), t);

        let log = A.map((x) => x.map((x) => x));
        log[0].push(b[0][0]);
        log[1].push(b[1][0]);
        log[2].push(b[2][0]);
        log.push([0.0, 0.0, 0.0, 0.0]);

        return log;
    }

    function se3_distance(se3_a, se3_b) {

        // console.log("se3");
        // console.log(se3_b);

        let o1_rot_T = transpose(get_SE3_rot_part(se3_a));
        let neg_T = [[-se3_a[0][3]], [-se3_a[1][3]], [-se3_a[2][3]]];
        
        let o1_t_rotd = mul_matrix_matrix(o1_rot_T, neg_T);

        let o1_inv = o1_rot_T.map((x) => x.map((x) => x));
        o1_inv[0].push(o1_t_rotd[0][0]);
        o1_inv[1].push(o1_t_rotd[1][0]);
        o1_inv[2].push(o1_t_rotd[2][0]);
        o1_inv.push([0.0, 0.0, 0.0, 1.0]);

        let disp = mul_matrix_matrix(o1_inv, se3_b);
        
        let se3_disp = SE3_log(disp);

        let a1 = se3_disp[2][1];
        let a2 = se3_disp[0][2];
        let a3 = se3_disp[1][0];
        let a4 = se3_disp[0][3];
        let a5 = se3_disp[1][3];
        let a6 = se3_disp[2][3];

        return Math.sqrt(a1*a1 + a2*a2 +
                a3*a3 + a4*a4 + a5*a5 + a6*a6);

    }

    function se3_from_uvector(u) {

        let beta2 = u[0] * u[0] + u[1] * u[1] + u[2] * u[2];
        let beta = Math.sqrt(beta2);

        let p = 0.0;
        let q = 0.0;

        if (beta < epsilon) {
            p = 1.0 - beta2/6 + beta2*beta2/120;
            p = 0.5 - beta2/24 + beta2*beta2/720;
        }
        else {
            p = Math.sin(beta) / beta;
            q = (1 - Math.cos(beta)) / beta2;
        }

        let so3 = [
            [0.0, -u[2], u[1]],
            [u[2], 0.0, -u[0]],
            [-u[1], u[0], 0.0],
        ];

        let so3_2 = mul_matrix_matrix(so3, so3);

        let sumpq = add_matrix_matrix(
            mul_matrix_scalar(so3, p),
            mul_matrix_scalar(so3_2, q)
        );

        let transform = [
            [1.0 + sumpq[0][0], sumpq[0][1], sumpq[0][2], 0.0],
            [sumpq[1][0], 1.0 + sumpq[1][1], sumpq[1][2], 0.0],
            [sumpq[2][0], sumpq[2][1], 1.0 + sumpq[2][2], 0.0],
            [0.0, 0.0, 0.0, 1.0]];
        
        return transform;
    }

    function se3_from_uvector_and_position(u, translate) {
        let rot = se3_from_uvector(u);
        rot[0][3] = translate[0];
        rot[1][3] = translate[1];
        rot[2][3] = translate[2];

        return rot;
    }

    function ik_from_ideal(parameters) {

        // console.log(ik_targets);

        let distance = 0.0;
        
        let pos_base = parameters.slice(0, 3);
        let u_base = parameters.slice(3, 6);

        let base_transform = se3_from_uvector_and_position(u_base, pos_base);
    

        distance += se3_distance(base_transform, ik_targets[0]);

        // for (let i = 0; i < legs.length; ++i) {
        //     let base_index = i * 12 + 6;

        //     let u_thigh = parameters.slice(base_index, base_index + 3);

        //     let pos_knee = parameters.slice(base_index+3, base_index + 6);
        //     let u_knee = parameters.slice(base_index+6, base_index + 9);

        //     let thigh_transform = se3_from_uvector(u_thigh);

        //     let knee_transform = se3_from_uvector_and_position(u_knee, pos_knee);

        //     // console.log("ik target", i, ik_targets[i].thigh);
        //     distance += se3_distance(thigh_transform, ik_targets[i+1].thigh);
        //     // distance += se3_distance(knee_transform, ik_targets[i+1].knee);
        // }

        return distance;
    }


    // robot.set_link_mesh_pose_from_SE3_matrix(engine, 1, joints[1].xyz_rpy_SE3_matrix);

    // let base_joint = joints[1].dof_idx;

    // this will spawn all of the robot's links at the origin
    // robot.spawn_robot(engine);
    let t = 0;

    function setObjMatrix(object, se3) {
        let l = mat_from_se3(se3);
        object.position.x = se3[0][3];
        object.position.y = se3[1][3];
        object.position.z = se3[2][3];
        object.setRotationFromMatrix(l);
    }

    params = [0.0, 0.0, 0.0, 0.0, 0.0, 0.0];

    engine.animation_loop( ()  => {

        ik_targets[0] = gizmos.get_gizmo_pose_as_SE3_matrix(gizmo);

        // if (se3_distance());

        let res = optimization_solve(ik_from_ideal, params, 50, 'bfgs');

        let pos_base = res.slice(0, 3);
        let u_base = res.slice(3, 6);

        let base_transform = se3_from_uvector_and_position(u_base, pos_base);

        let result = mul_matrix_matrix(default_transforms[0], base_transform);

        setObjMatrix(root_bone, result);

        // console.log(res);

        // console.log(base_transform);
        // console.log(se3_from_mat(root_bone.matrix));
        // console.log(se3_distance(base_transform, se3_from_mat(root_bone.matrix)));
        // root_bone.matrix.set(mat_from_se3(base_transform));

        // let m = se3_from_uvector_and_position([
        //     settings.dof0, settings.dof1, settings.dof2], [settings.dof3,
        //     settings.dof4, settings.dof5]);

        // console.log(m);
        // console.log(mat_from_se3(m));
        // console.log(se3_from_mat(root_bone.matrix));
        // alert(1);


        // console.log(se3_distance(s, ik_targets[0]))

        // for (let i = 0; i < legs.length; ++i) {
        //     let base_index = i * 12 + 6;

        //     let u_thigh = res.slice(base_index, base_index + 3);

        //     let pos_knee = res.slice(base_index+3, base_index + 6);
        //     let u_knee = res.slice(base_index+6, base_index + 9);
        // }


        // params = res;


        // if (t > 1) {
        //     console.log(gizmos.get_gizmo_pose_as_SO3_matrix_and_position(gizmo));
        //     t = 0.0;
        // }
        // t += 0.05;

        // for (let i = 1; i < links.length; ++i) {

        // // for (let i = 0; i < joint_ids.length; ++i) {
        //     let link = links[i];
            
        //     let joint = joints[link.parent_joint_idx];
        //     let transform = se3_from_joint(joint);
        
        //     while (link.parent_joint_idx > 0) {
        //         // let new_joint = se3_from_joint(joints[joint.parent_link_idx]);
        //         // console.log(joint.parent_link_idx);
        //         let parent_link = links[link.parent_link_idx];
        //         // console.log(parent_link.parent_joint_idx);
        //         let new_joint = se3_from_joint(joints[parent_link.parent_joint_idx]);
        //         transform = mul_matrix_matrix(new_joint, transform);
        //         // console.log(joint.joint_idx);
        //         // console.log(joint.parent_link_idx);
        //         // joint = joint.parent_link_idx;
        //         link = parent_link;
        //     }
        //     // console.log(i);
        //     robot.set_link_mesh_pose_from_SE3_matrix(engine, i, transform);
        // }
    });

</script>
</body>
</html>